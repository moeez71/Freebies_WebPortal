// ______________________________________________________
// Generated by sql2java - http://sql2java.sourceforge.net/
// jdbc driver used at code generation time: com.mysql.jdbc.Driver
//
// Author: Javed Kansi
// ______________________________________________________

package uk.co.planetbeyond.service.generated.util;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;

import org.slf4j.Logger;

import uk.co.planetbeyond.service.generated.ConnectionProfile;
import uk.co.planetbeyond.service.generated.Manager;
import uk.co.planetbeyond.util.ThroughputManager;

public abstract class BatchProcessor<T> extends Processor<T>
{
	/**
	 * Number of entries that will be fetched from database at a time
	 */
	private int batchSize;

	private Logger log;

	/**
	 * Throughput manager
	 */
	private ThroughputManager throughputManager;
	private boolean shutdown = false;
	private boolean appendLimitToSelectQuery = true;

	public BatchProcessor(String processName, int batchSize, Logger log, int throughputPerSec, boolean appendLimitToSelectQuery)
	{
		super(processName, log);
		this.batchSize = batchSize;
		this.log = log;
		this.processName = processName;
		this.appendLimitToSelectQuery = appendLimitToSelectQuery;
		this.throughputManager = new ThroughputManager(throughputPerSec);
	}


	public BatchProcessor(String processName, int batchSize, Logger log, int throughputPerSec, int scheduledAutoRenewalJobId)
	{
		super(processName, scheduledAutoRenewalJobId, log);
		this.batchSize = batchSize;
		this.log = log;
		this.processName = processName;
		this.scheduledAutoRenewalJobId = scheduledAutoRenewalJobId;
		this.appendLimitToSelectQuery = true;
		this.throughputManager = new ThroughputManager(throughputPerSec);
	}
	
	public BatchProcessor(String processName, int batchSize, Logger log, int throughputPerSec)
	{
		this(processName, batchSize, log, throughputPerSec, true);
	}

	private int getTotalCount() throws SQLException
	{
		ConnectionProfile cp = null;

		try
		{
			// prepare query parameters
			ArrayList<Object> parameters = new ArrayList<Object>();

			// parameters that needs to be added to the query will be added manually
			prepareQueryParametersForCountQuery(parameters);

			cp = Manager.getInstance().executeQueryByPreparedStatement(getCountQuery(), parameters.toArray());

			if (cp.getResultSet().next())
			{
				return cp.getResultSet().getInt(1);
			}
			else
			{
				throw new IllegalArgumentException("Count query did not return any row: " + getCountQuery());
			}
		}
		finally
		{
			Manager.getInstance().close(cp);
		}
	}

	private ArrayList<T> getNextBatch(T lastEntry) throws SQLException
	{
		ArrayList<T> retVal = new ArrayList<T>();

		// prepare query parameters
		ArrayList<Object> parameters = new ArrayList<Object>();

		// parameters that needs to be added to the query will be added manually except for the LIMIT parameter
		prepareQueryParametersForSelectQuery(lastEntry, parameters);

		// the last parameter will be for LIMIT
		parameters.add(new Integer(batchSize));

		ConnectionProfile cp = null;

		try
		{
			// append LIMIT condition to the select query and execute it
			cp = Manager.getInstance().executeQueryByPreparedStatement(getSelectQuery() + (appendLimitToSelectQuery ? " LIMIT ?" : ""), parameters.toArray());

			// add entries from result set to the list and return it
			while (cp.getResultSet().next())
			{
				retVal.add(decodeRow(cp.getResultSet()));
			}

			// safety check to make sure that different batches return different results. If the last entry of previous batch matches the last entry
			// of newly fetched batch, display a warning in the log file. In order for this to work, the generic class T must have a proper
			// implementation of equals()
			if (retVal.size() > 0 && retVal.get(retVal.size() - 1).equals(lastEntry))
			{
				log.warn("The select query (probably) returned same entries for multiple batches. Make sure the query is correct. Last entry of previous and new batch match: {},  Query: {}", lastEntry.toString(), getSelectQuery());
			}

			return retVal;
		}
		finally
		{
			Manager.getInstance().close(cp);
		}
	}

	@Override
	public ProcessReturnValue process()
	{
		ProcessReturnValue retVal;
		try
		{
			// a function which can be overriden to resume previously stopped cycle
			T lastEntry = initLastEntryFromPersistentState();
			boolean resumed = false;

			// if no previously saved state is found, initialize from the start using the function below
			if (lastEntry == null)
			{
				lastEntry = initLastEntry();
			}

			// set the flag that the batch job has been resumed instead of starting from scratch
			else
			{
				resumed = true;
			}

			// make sure the overridden getSelectQuery method has an ORDER BY clause
			if (getSelectQuery() == null || getSelectQuery().toLowerCase().indexOf("order by") == -1)
			{
				throw new IllegalArgumentException("Invalid select query. The select query MUST contain an ORDER BY clause: " + getSelectQuery());
			}

			int totalEntries = getTotalCount();

			int totalEntriesProcessed = 0;
			int remainingEntries = totalEntries;

			// if the job has been resumed, then fetch the remaining entries from BDB. The implementation of this function is provided by
			// ResumeableBatchProcessor
			if (resumed)
			{
				remainingEntries = getRemainingEntriesAfterResume();
			}

			while (true)
			{
				log.info("{}: Remaining entries={}/{}", new Object[] { processName, remainingEntries, totalEntries });

				// shutdown check
				if (shutdown == true || proceedExecution() == false)
				{
					log.info("{}: Process shut down. Total number of entries processed successfully={}/{}", new Object[] { processName, totalEntriesProcessed, totalEntries });

					// if the application is properly closed, the exact last entry can be made persistent
					persistLastEntry(lastEntry, remainingEntries);
					retVal = ProcessReturnValue.SHUTDOWN_OCCURED;
					break;
				}

				// fetch batch of entries to process
				ArrayList<T> batch = getNextBatch(lastEntry);

				// if nothing is returned, stop
				if (batch == null || batch.size() == 0)
				{
					log.info("{}: Process finished successfully. Total number of entries processed={}", processName, totalEntriesProcessed);

					// function that can be used to remove persistent state when the cycle completes successfully
					removePersistentState();
					retVal = ProcessReturnValue.COMPLETED_SUCCESSFULLY;
					break;
				}

				// this check handles the case if the application is closed abnormally. Note that since one batch will be skipped if the job is
				// stopped or it crashes which is why batch size is being subtracted from remaining entries here
				persistLastEntry(batch.get(batch.size() - 1), remainingEntries - batch.size());

				// process each entry. this code is surrounded by try catch block so that problem with a single entry does not stop the entire process
				for (T entry : batch)
				{
					try
					{
						// before the next entry is processed, check for the shutdown flag
						if (shutdown)
						{
							break;
						}

						// update counts for logging purposes
						totalEntriesProcessed++;
						remainingEntries--;

						// update the pointer which point to the last entry processed (if the application is closed properly and last entry is made
						// persistent then the process can resume from the exact place where it left off before the shutdown)
						lastEntry = entry;

						// let the child class process the entry
						processEntry(entry);
					}
					catch (Exception e)
					{
						log.error(e.toString(), e);

						// to avoid running into a blind loop
						Thread.sleep(100);
					}
				}
			}
		}
		catch (Throwable e)
		{
			retVal = ProcessReturnValue.EXCEPTION_OCCURED;
			retVal.setException(e);
		}

		return retVal;
	}

	/**
	 * This is the main entry point in to this class. This function fetches batches from database and calls processEntry for each entry in the batch.
	 * It returns when there are no more batches left to process
	 */
	public void startBatchProcess()
	{
		log.info("Going to start batch process: {}", processName);
		startProcess();
	}

	protected int getRemainingEntriesAfterResume()
	{
		return -100;
	}

	protected void removePersistentState()
	{

	}

	protected T initLastEntryFromPersistentState()
	{
		return null;
	}

	protected ThroughputManager getThroughputManager()
	{
		return throughputManager;
	}

	/**
	 * In order to apply throughput per second, this function can be called in processEntry along with the appropriate message text
	 * 
	 * @param messageText
	 */
	protected void sleepToMatchThroughput(String messageText)
	{
		throughputManager.sleepToMatchThroughput(messageText);
	}

	/**
	 * Stops a running process
	 */
	public void shutdown()
	{
		shutdown = true;
	}

	/**
	 * Returns TRUE if next entry is to be processed. FALSE if batch processing needs to be stopped. This is not an abstract function and by default
	 * it always returns TRUE but this behavior can be changed by overriding the function
	 * 
	 * @return
	 */
	public boolean proceedExecution()
	{
		return true;
	}

	/**
	 * This method is called before the batch process is started. Child class can use this function for any kind of initialization it needs
	 */
	protected abstract void init();

	/**
	 * This function should return the first value which is assigned to the lastEntry variable. For example incase of auto renewal where we need to
	 * fetch MSISDNs in sorted order this function can return "0"
	 * 
	 * @return
	 */
	protected abstract T initLastEntry();

	/**
	 * This function is called from time to time in order the persist the current lastEntry. This can be used to resume the process if its stopped in
	 * the middle of processing
	 * 
	 * @param lastEntry
	 * @param remainingEntries
	 */
	protected void persistLastEntry(T lastEntry, int remainingEntries)
	{

	}

	/**
	 * This function is called when the process completes successfully
	 */
	protected abstract void onComplete();

	/**
	 * This function is called when the process is terminated by calling the shutdown() function
	 */
	protected abstract void onShutdown();

	@Override
	protected void onProcessingException(Throwable e)
	{
		log.error(e.toString(), e);
	}

	/**
	 * This is the main function that contains the logic for processing each entry
	 * 
	 * @param entry
	 * @throws Exception
	 */
	protected abstract void processEntry(T entry) throws Exception;

	/**
	 * This function is used to decode a row which is returned by the query in getSelectQuery() function
	 * 
	 * @param resultSet
	 * @return
	 * @throws SQLException
	 */
	protected abstract T decodeRow(ResultSet resultSet) throws SQLException;

	/**
	 * This function must return a query which will return a list of entries that needs to be processed. It can have placeholders (question marks).
	 * For each placeholder in this query, appropriate value must be added to parameters by the prepareQueryParametersForSelectQuery function. This
	 * query MUST contain an ORDER BY clause in order to make sure the entries from database are returned in the correct order and it MUST NOT contain
	 * a LIMIT condition (LIMIT condition is added automatically)
	 * 
	 * @return
	 */
	protected abstract String getSelectQuery();

	/**
	 * For each placeholder (question mark) in select query, appropriate value must be added to parameters by this function in the correct order
	 * 
	 * @param lastEntry
	 * @param parameters
	 */
	protected abstract void prepareQueryParametersForSelectQuery(T lastEntry, ArrayList<Object> parameters);

	/**
	 * This function must return a count query that should return all entries that will eventually be processed. It can have placeholders (question
	 * marks). For each placeholder in this query, appropriate value must be added to parameters by the prepareQueryParametersForCountQuery function
	 * 
	 * @return
	 */
	protected abstract String getCountQuery();

	/**
	 * For each placeholder (question mark) in count query, appropriate value must be added to parameters by this function in the correct order
	 * 
	 * @param parameters
	 */
	protected abstract void prepareQueryParametersForCountQuery(ArrayList<Object> parameters);
}
