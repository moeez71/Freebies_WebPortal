


// ______________________________________________________
// Generated by sql2java - http://sql2java.sourceforge.net/
// jdbc driver used at code generation time: com.mysql.jdbc.Driver
//
// Author: Javed Kansi
// ______________________________________________________

package uk.co.planetbeyond.service.generated;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import org.joda.time.DateTime;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import uk.co.planetbeyond.util.SystemUtil;

/**
 * Monitors all database connections that are opened and checks for connection leaks
 * 
 * @author Javed
 *
 */
public class ConnectionDebugInfo
{
	private static boolean shutdown = false;
	private static Thread monitorThread;

	// millies after which the monitor thread will check for leaked connections
	public static int MONITOR_THREAD_SLEEP_INTERVAL_IN_MILLIES = 5000;

	// millies after which a connection should be considered as leaked if it is not closed
	public static int CONNECTION_EXPIRY_INTERVAL_IN_MILLIES = 300 * 1000;

	private static Logger log = LoggerFactory.getLogger(ConnectionDebugInfo.class);

	// map that stores all open connections and the thread which acquired those connections
	private static Map<String, ConnectionDebugInfo> connectionDebugInfo = new HashMap<String, ConnectionDebugInfo>();

	// name of the thread which acquires the connections
	private String threadName;

	// stack trace of the get connection function
	private String stackTrace;

	// time at which the connection is created
	private DateTime createdTimestamp;

	private ConnectionDebugInfo()
	{
		this.threadName = Thread.currentThread().getName();
		this.stackTrace = SystemUtil.parseStackTrace(Thread.currentThread().getStackTrace());
		this.createdTimestamp = DateTime.now();
	}

	public String getStackTrace()
	{
		return stackTrace;
	}

	public String getThreadName()
	{
		return threadName;
	}

	public void setThreadName(String threadName)
	{
		this.threadName = threadName;
	}

	public void setStackTrace(String stackTrace)
	{
		this.stackTrace = stackTrace;
	}

	public DateTime getCreatedTimestamp()
	{
		return createdTimestamp;
	}

	public void setCreatedTimestamp(DateTime createdTimestamp)
	{
		this.createdTimestamp = createdTimestamp;
	}

	/**
	 * This function is called when the current thread creates a new connection. It stores the stack trace and the creation time as well as the name
	 * of the thread
	 * 
	 * @return
	 */
	public static boolean addConnectionDebugInfo()
	{
		boolean unclosedConnectionFound = false;

		synchronized (connectionDebugInfo)
		{
			// if the value is already set, it means that previous connection was not closed properly hence we should log an error
			if (connectionDebugInfo.get(Thread.currentThread().getName()) != null)
			{
				logError(connectionDebugInfo.get(Thread.currentThread().getName()));
				unclosedConnectionFound = true;
			}

			connectionDebugInfo.put(Thread.currentThread().getName(), new ConnectionDebugInfo());
		}

		return unclosedConnectionFound;
	}

	/**
	 * This function is called when the current thread closes a connection. Removes the connection from the list of monitored connections
	 * 
	 */
	public static void removeConnectionDebugInfo()
	{
		synchronized (connectionDebugInfo)
		{
			connectionDebugInfo.remove(Thread.currentThread().getName());
		}
	}

	/**
	 * If a given interval is passed after acquired the connection, this function will return true
	 * 
	 * @return
	 */
	protected boolean hasExpired()
	{
		return createdTimestamp.plusMillis(CONNECTION_EXPIRY_INTERVAL_IN_MILLIES).isBefore(DateTime.now());
	}

	@Override
	public String toString()
	{
		return "ConnectionDebugInfo [threadName=" + threadName + ", createdTimestamp=" + createdTimestamp + ", stackTrace=" + stackTrace + "]";
	}

	private static void logError(ConnectionDebugInfo connectionDebugInfo)
	{
		log.error("Unclosed database connection found. {}", connectionDebugInfo.toString());
	}

	/**
	 * Searches, returns and logs the list of connections that were acqiured but not closed within the given timeout
	 * 
	 * @return
	 */
	public static ArrayList<ConnectionDebugInfo> searchExpiredRecords()
	{
		ArrayList<ConnectionDebugInfo> retVal = new ArrayList<ConnectionDebugInfo>();

		synchronized (connectionDebugInfo)
		{
			for (Iterator<Map.Entry<String, ConnectionDebugInfo>> iterator = connectionDebugInfo.entrySet().iterator(); iterator.hasNext();)
			{
				Map.Entry<String, ConnectionDebugInfo> entry = iterator.next();

				if (entry.getValue().hasExpired())
				{
					logError(entry.getValue());
					retVal.add(entry.getValue());
					iterator.remove();
				}
			}
		}

		return retVal;
	}

	/**
	 * Starts an internal thread that keeps monitoring leaked connections
	 * 
	 */
	public static void startMonitorThread(Object connectionExpiryIntervalInSecs)
	{
		if (connectionExpiryIntervalInSecs != null)
		{
			CONNECTION_EXPIRY_INTERVAL_IN_MILLIES = Integer.valueOf(connectionExpiryIntervalInSecs.toString()) * 1000;
		}

		monitorThread = new Thread(new Runnable()
		{
			@Override
			public void run()
			{
				while (shutdown == false)
				{
					try
					{
						Thread.sleep(MONITOR_THREAD_SLEEP_INTERVAL_IN_MILLIES);
					}
					catch (InterruptedException e)
					{
						Thread.interrupted();
						return;
					}

					searchExpiredRecords();
				}
			}
		});

		monitorThread.setDaemon(true);
		monitorThread.start();
	}

	/**
	 * Stops an internal thread that keeps monitoring leaked connections
	 * 
	 */
	public static void stopMonitorThread()
	{
		shutdown = true;
		monitorThread.interrupt();

		monitorThread = null;
	}
}

